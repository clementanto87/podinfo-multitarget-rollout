name: Promote Podinfo to Production

on:
  workflow_dispatch:
    inputs:
      image_digest:
        description: 'Image digest to promote to production (sha256:...)'
        required: true

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: eu-west-1
  IMAGE_NAME: podinfo
  DEPLOY_ENV: prod
  AWS_ACCOUNT_ID: "910246205478" # Replace with your AWS Account ID

jobs:
  promote-to-prod:
    name: Promote to Production
    runs-on: ubuntu-latest
    timeout-minutes: 60

    # This environment must be configured in the repository settings
    # to require manual approval.
    environment: production

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/github-actions-oidc-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Verify image signature (cosign keyless)
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_DIGEST: ${{ github.event.inputs.image_digest }}
          COSIGN_EXPERIMENTAL: "1"
        run: |
          set -euo pipefail
          echo "Verifying image signature for $ECR_REGISTRY/${{ env.IMAGE_NAME }}@$IMAGE_DIGEST"
          curl -fsSL -o /usr/local/bin/cosign "https://github.com/sigstore/cosign/releases/download/v2.2.4/cosign-linux-amd64"
          chmod +x /usr/local/bin/cosign
          cosign verify \
            "$ECR_REGISTRY/${{ env.IMAGE_NAME }}@$IMAGE_DIGEST" \
            --certificate-oidc-issuer "https://token.actions.githubusercontent.com" \
            --certificate-identity-regexp "https://github.com/.+"
      

      - name: Install Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.6

      # --- Parallel Terraform Apply ---
      - name: Deploy Lambda and EC2 Stacks in Parallel
        run: |
          set -euo pipefail
          # Run Lambda apply in the background
          (
            cd infra/lambda
            echo "INFO: Initializing Terraform for Lambda..."
            terraform init -input=false \
              -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
              -backend-config="key=infra/lambda/${{ env.DEPLOY_ENV }}.tfstate" \
              -backend-config="region=${{ env.AWS_REGION }}" \
              -backend-config="dynamodb_table=terraform-state-locks"
            echo "INFO: Applying Terraform for Lambda..."
            terraform apply -auto-approve \
              -var="region=${{ env.AWS_REGION }}" \
              -var="deploy_env=${{ env.DEPLOY_ENV }}" \
              -var="super_secret_token_arn=arn:aws:secretsmanager:${{ env.AWS_REGION }}:${{ env.AWS_ACCOUNT_ID }}:secret:podinfo/super-secret-token" \
              -var="ecr_repo_url=${{ steps.login-ecr.outputs.registry }}/${{ env.IMAGE_NAME }}" \
              -var="image_digest=${{ github.event.inputs.image_digest }}"
            echo "INFO: Terraform apply for Lambda finished."
          ) &
          LAMBDA_PID=$!
          # Run EC2 apply in the background
          (
            cd infra/ec2
            echo "INFO: Initializing Terraform for EC2..."
            terraform init -input=false \
              -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
              -backend-config="key=infra/ec2/${{ env.DEPLOY_ENV }}.tfstate" \
              -backend-config="region=${{ env.AWS_REGION }}" \
              -backend-config="dynamodb_table=terraform-state-locks"
            echo "INFO: Applying Terraform for EC2..."
            terraform apply -auto-approve \
              -var="region=${{ env.AWS_REGION }}" \
              -var="deploy_env=${{ env.DEPLOY_ENV }}" \
              -var="super_secret_token_arn=arn:aws:secretsmanager:${{ env.AWS_REGION }}:${{ env.AWS_ACCOUNT_ID }}:secret:podinfo/super-secret-token" \
              -var="ecr_repo_url=${{ steps.login-ecr.outputs.registry }}/${{ env.IMAGE_NAME }}" \
              -var="image_digest=${{ github.event.inputs.image_digest }}"
            echo "INFO: Terraform apply for EC2 finished."
          ) &
          EC2_PID=$!
          # Wait for both background jobs to complete
          wait $LAMBDA_PID
          wait $EC2_PID

      # --- Create and Trigger CodeDeploy Deployments ---
      - name: Create and Trigger CodeDeploy for Lambda and EC2
        run: |
          set -euo pipefail
          # Lambda Deployment
          (
            cd infra/lambda
            cat > appspec.yaml <<EOF
            version: 0.0
            Resources:
              - TargetService:
                  Type: AWS::Lambda::Function
                  Properties:
                    Name: "podinfo-${{ env.DEPLOY_ENV }}"
                    Alias: "live"
                    CurrentVersion: "1" # These versions are placeholders
                    TargetVersion: "2" # CodeDeploy will determine the actual versions
            EOF
            APPSPEC_CONTENT=$(yq -o=json -I=0 < appspec.yaml | tr -d '\n')
            APPSPEC_SHA256=$(echo -n "$APPSPEC_CONTENT" | sha256sum | cut -d' ' -f1)
            jq -n --arg content "$APPSPEC_CONTENT" --arg sha "$APPSPEC_SHA256" \
              '{revisionType: "AppSpecContent", appSpecContent: {content: $content, sha256: $sha}}' > appspec-content.json
            LAMBDA_DEPLOY_ID=$(aws deploy create-deployment \
              --application-name "podinfo-lambda-${{ env.DEPLOY_ENV }}" \
              --deployment-group-name "lambda-group-${{ env.DEPLOY_ENV }}" \
              --revision file://appspec-content.json \
              --description "Deploy ${{ github.event.inputs.image_digest }}" \
              --query deploymentId --output text)
            echo "LAMBDA_CODEDEPLOY_ID=$LAMBDA_DEPLOY_ID" >> $GITHUB_ENV
          ) &
          # EC2 Deployment
          (
            mkdir -p deployment/scripts
            cp -r scripts/*.sh scripts/appspec.yml deployment/scripts/
            echo "IMAGE_URI=${{ steps.login-ecr.outputs.registry }}/${{ env.IMAGE_NAME }}@${{ github.event.inputs.image_digest }}" > deployment/scripts/.env
            cd deployment && zip -r ../deployment.zip .
            aws s3 cp deployment.zip s3://${{ secrets.TF_STATE_BUCKET }}/deployments/podinfo-${{ env.DEPLOY_ENV }}-${{ github.run_id }}.zip
            EC2_DEPLOY_ID=$(aws deploy create-deployment \
              --application-name "podinfo-ec2-${{ env.DEPLOY_ENV }}" \
              --deployment-group-name "ec2-group-${{ env.DEPLOY_ENV }}" \
              --s3-location bucket=${{ secrets.TF_STATE_BUCKET }},key=deployments/podinfo-${{ env.DEPLOY_ENV }}-${{ github.run_id }}.zip,bundleType=zip \
              --description "Deploy ${{ github.event.inputs.image_digest }}" \
              --query deploymentId --output text)
            echo "EC2_CODEDEPLOY_ID=$EC2_DEPLOY_ID" >> $GITHUB_ENV
          ) &
          wait

      # --- Wait for Deployments to Complete ---
      - name: Wait for CodeDeploy Rollouts in Parallel
        run: |
          set -euo pipefail
          echo "Waiting for Lambda deployment: $LAMBDA_CODEDEPLOY_ID"
          aws deploy wait deployment-successful --deployment-id "$LAMBDA_CODEDEPLOY_ID" &
          LAMBDA_WAIT_PID=$!
          echo "Waiting for EC2 deployment: $EC2_CODEDEPLOY_ID"
          aws deploy wait deployment-successful --deployment-id "$EC2_CODEDEPLOY_ID" &
          EC2_WAIT_PID=$!
          wait $LAMBDA_WAIT_PID
          wait $EC2_WAIT_PID
          echo "Both deployments completed successfully."

      # --- Final Smoke Tests ---
      - name: Fetch Endpoints
        id: fetch-endpoints
        run: |
          LAMBDA_URL=$(cd infra/lambda && terraform output -raw lambda_api_url)
          ALB_DNS=$(cd infra/ec2 && terraform output -raw alb_dns)
          echo "lambda_url=$LAMBDA_URL" >> $GITHUB_OUTPUT
          echo "alb_dns=$ALB_DNS" >> $GITHUB_OUTPUT

      - name: Run Final Smoke Tests
        run: |
          set -euo pipefail
          echo "Running smoke tests..."
          ./scripts/smoke_tests.sh ${{ steps.fetch-endpoints.outputs.lambda_url }} ${{ steps.fetch-endpoints.outputs.alb_dns }}

      - name: Summary
        run: |
          echo "### Promotion to Production Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Status:** Success" >> $GITHUB_STEP_SUMMARY
          echo "- **Image:** `${{ env.IMAGE_NAME }}@${{ github.event.inputs.image_digest }}`" >> $GITHUB_STEP_SUMMARY
          echo "- **Lambda URL:** `${{ steps.fetch-endpoints.outputs.lambda_url }}`" >> $GITHUB_STEP_SUMMARY
          echo "- **ALB DNS:** `${{ steps.fetch-endpoints.outputs.alb_dns }}`" >> $GITHUB_STEP_SUMMARY
