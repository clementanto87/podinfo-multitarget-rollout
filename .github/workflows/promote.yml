# .github/workflows/promote.yml
name: Promote Podinfo Image to Production

on:
  workflow_dispatch:
    inputs:
      image_digest:
        description: "Immutable image digest to promote (sha256:...)"
        required: true

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: eu-west-1
  IMAGE_NAME: podinfo
  DEPLOY_ENV: prod
  AWS_ACCOUNT_ID: "910246205478"

jobs:
  approval:
    name: Manual Approval Gate
    runs-on: ubuntu-latest
    environment:
      name: production
      url: https://console.aws.amazon.com/
    steps:
      - name: Confirm Promotion
        run: echo "Awaiting manual approval before promoting to production..."

  promote:
    name: Deploy to Production (Dual-Target)
    runs-on: ubuntu-latest
    needs: approval
    timeout-minutes: 60
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Install yq, jq, and zip
        run: |
          sudo apt-get update
          sudo apt-get install -y jq zip
          curl -L https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -o /usr/local/bin/yq
          chmod +x /usr/local/bin/yq

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/github-actions-oidc-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Verify Cosign signature (keyless)
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_DIGEST: ${{ github.event.inputs.image_digest }}
        run: |
          set -euo pipefail
          echo "Verifying cosign signature for prod promotion..."
          if ! command -v cosign >/dev/null 2>&1; then
            COSIGN_VERSION=$(curl -s https://api.github.com/repos/sigstore/cosign/releases/latest | grep tag_name | cut -d '"' -f4)
            curl -sSL -o /usr/local/bin/cosign "https://github.com/sigstore/cosign/releases/download/${COSIGN_VERSION}/cosign-linux-amd64"
            chmod +x /usr/local/bin/cosign
          fi
          cosign verify --keyless "$ECR_REGISTRY/${{ env.IMAGE_NAME }}@$IMAGE_DIGEST"

      - name: Install Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.6

      # -------------------------------------------------
      # LAMBDA: Reuse existing infra, trigger CodeDeploy
      # -------------------------------------------------
      - name: Refresh Lambda infra state (prod)
        working-directory: infra/lambda
        run: |
          set -euo pipefail
          terraform init -input=false \
            -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
            -backend-config="key=infra/lambda/prod.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="dynamodb_table=terraform-state-locks"
          # No apply â€” infra already exists

      - name: Generate AppSpec for Lambda CodeDeploy (prod)
        working-directory: infra/lambda
        run: |
          cat > appspec.yaml <<EOF
          version: 0.0
          Resources:
            - TargetService:
                Type: AWS::Lambda::Function
                Properties:
                  Name: "podinfo-prod"
                  Alias: "live"
                  CurrentVersion: "1"
                  TargetVersion: "2"
          EOF

      - name: Create Lambda CodeDeploy Deployment (prod)
        env:
          ECR_REPO_URL: ${{ steps.login-ecr.outputs.registry }}/${{ env.IMAGE_NAME }}
        run: |
          set -euo pipefail
          APPSPEC_JSON=$(cat infra/lambda/appspec.yaml | yq -o=json | jq -R .)
          APPSPEC_SHA256=$(sha256sum infra/lambda/appspec.yaml | cut -d' ' -f1)
          cat > appspec-content.json <<EOF
          {
            "revisionType": "AppSpecContent",
            "appSpecContent": {
              "content": $APPSPEC_JSON,
              "sha256": "$APPSPEC_SHA256"
            }
          }
          EOF
          DEPLOYMENT_ID=$(aws deploy create-deployment \
            --application-name "podinfo-lambda-prod" \
            --deployment-group-name "lambda-group-prod" \
            --revision file://appspec-content.json \
            --description "Promote ${{ github.event.inputs.image_digest }}" \
            --query deploymentId --output text)
          echo "LAMBDA_CODEDEPLOY_ID=$DEPLOYMENT_ID" >> $GITHUB_ENV

      - name: Wait for Lambda CodeDeploy (prod)
        if: env.LAMBDA_CODEDEPLOY_ID != ''
        run: |
          aws deploy wait deployment-successful --deployment-id "$LAMBDA_CODEDEPLOY_ID"

      # -------------------------------------------------
      # EC2: Reuse infra, deploy new bundle
      # -------------------------------------------------
      - name: Refresh EC2 infra state (prod)
        working-directory: infra/ec2
        run: |
          set -euo pipefail
          terraform init -input=false \
            -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
            -backend-config="key=infra/ec2/prod.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="dynamodb_table=terraform-state-locks"

      - name: Create EC2 deployment bundle (prod)
        run: |
          mkdir -p deployment/scripts
          cp -r scripts/*.sh scripts/appspec.yml deployment/scripts/
          echo "IMAGE_URI=${{ steps.login-ecr.outputs.registry }}/${{ env.IMAGE_NAME }}@${{ github.event.inputs.image_digest }}" > deployment/scripts/.env
          echo "SUPER_SECRET_TOKEN_ARN=arn:aws:secretsmanager:${{ env.AWS_REGION }}:${{ env.AWS_ACCOUNT_ID }}:secret:podinfo/super-secret-token" >> deployment/scripts/.env
          echo "AWS_REGION=${{ env.AWS_REGION }}" >> deployment/scripts/.env
          cd deployment
          zip -r ../deployment.zip .

      - name: Upload bundle to S3
        run: |
          aws s3 cp deployment.zip s3://${{ secrets.TF_STATE_BUCKET }}/deployments/podinfo-prod-${{ github.run_id }}.zip

      - name: Create EC2 CodeDeploy Deployment (prod)
        run: |
          DEPLOYMENT_ID=$(aws deploy create-deployment \
            --application-name "podinfo-ec2-prod" \
            --deployment-group-name "ec2-group-prod" \
            --s3-location bucket=${{ secrets.TF_STATE_BUCKET }},key=deployments/podinfo-prod-${{ github.run_id }}.zip,bundleType=zip \
            --description "Promote ${{ github.event.inputs.image_digest }}" \
            --query deploymentId --output text)
          echo "EC2_CODEDEPLOY_ID=$DEPLOYMENT_ID" >> $GITHUB_ENV

      - name: Wait for EC2 CodeDeploy (prod)
        if: env.EC2_CODEDEPLOY_ID != ''
        run: |
          aws deploy wait deployment-successful --deployment-id "$EC2_CODEDEPLOY_ID"

      # -------------------------------------------------
      # Final validation
      # -------------------------------------------------
      - name: Fetch prod endpoints
        run: |
          LAMBDA_URL=$(cd infra/lambda && terraform output -raw lambda_api_url 2>/dev/null || echo "")
          ALB_DNS=$(cd infra/ec2 && terraform output -raw alb_dns 2>/dev/null || echo "")
          echo "LAMBDA_URL=$LAMBDA_URL" >> $GITHUB_ENV
          echo "ALB_DNS=$ALB_DNS" >> $GITHUB_ENV

      - name: Run smoke tests (prod)
        env:
          LAMBDA_URL: ${{ env.LAMBDA_URL }}
          ALB_DNS: ${{ env.ALB_DNS }}
        run: |
          set -euo pipefail
          if [ -n "$LAMBDA_URL" ]; then
            curl -sfS "$LAMBDA_URL/healthz"
          fi
          if [ -n "$ALB_DNS" ]; then
            curl -sfS "http://$ALB_DNS/healthz"
          fi

      - name: Promotion Summary
        run: |
          echo "### Production Promotion Summary" >> $GITHUB_STEP_SUMMARY
          echo "- Image digest: \`${{ github.event.inputs.image_digest }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Environment: prod" >> $GITHUB_STEP_SUMMARY
          echo "- Promoted by: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- Lambda URL: ${{ env.LAMBDA_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "- ALB DNS: ${{ env.ALB_DNS }}" >> $GITHUB_STEP_SUMMARY