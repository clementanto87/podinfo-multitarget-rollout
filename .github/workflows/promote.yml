name: Promote Podinfo (Dev -> Prod)

on:
  workflow_dispatch:
    inputs:
      image_digest:
        description: 'Image digest to deploy to Dev and then promote to Prod (e.g., sha256:...)'
        required: true

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: eu-west-1
  IMAGE_NAME: podinfo
  # Use GitHub Secrets for your AWS Account ID and S3 bucket for better security
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  TF_STATE_BUCKET: ${{ secrets.TF_STATE_BUCKET }}

jobs:
  # ===================================================================
  #  JOB 1: Deploy to the 'dev' environment
  # ===================================================================
  deploy-dev:
    name: Deploy to Dev
    runs-on: ubuntu-latest
    environment: dev # Links to the 'dev' GitHub Environment for visibility
    timeout-minutes: 30

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Install dependencies (jq, yq, zip)
        run: |
          sudo apt-get update && sudo apt-get install -y jq zip
          sudo curl -L https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -o /usr/local/bin/yq && sudo chmod +x /usr/local/bin/yq

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/github-actions-oidc-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Verify image signature (Cosign)
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_DIGEST: ${{ github.event.inputs.image_digest }}
          COSIGN_EXPERIMENTAL: "1"
        run: |
          echo "Verifying image signature for $ECR_REGISTRY/$IMAGE_NAME@$IMAGE_DIGEST"
          # Using a fixed version for reproducibility
          curl -fsSL -o /usr/local/bin/cosign "https://github.com/sigstore/cosign/releases/download/v2.2.4/cosign-linux-amd64"
          chmod +x /usr/local/bin/cosign
          cosign verify \
            "$ECR_REGISTRY/$IMAGE_NAME@$IMAGE_DIGEST" \
            --certificate-oidc-issuer "https://token.actions.githubusercontent.com" \
            --certificate-identity-regexp "https://github.com/.+"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.6

      # --- DEPLOYMENT LOGIC (PARAMETERIZED FOR 'dev') ---
      # This block can be extracted into a reusable workflow to keep it DRY

      - name: Deploy Infrastructure (Terraform)
        id: terraform-apply
        env:
          DEPLOY_ENV: dev
          ECR_REPO_URL: ${{ steps.login-ecr.outputs.registry }}/${{ env.IMAGE_NAME }}
          IMAGE_DIGEST: ${{ github.event.inputs.image_digest }}
          SUPER_SECRET_TOKEN_ARN: arn:aws:secretsmanager:${{ env.AWS_REGION }}:${{ env.AWS_ACCOUNT_ID }}:secret:podinfo/dev/super-secret-token
        run: |
          set -euo pipefail
          # Deploy Lambda Stack
          cd infra/lambda
          terraform init -input=false -backend-config="bucket=${{ env.TF_STATE_BUCKET }}" -backend-config="key=infra/lambda/$DEPLOY_ENV.tfstate" -backend-config="region=${{ env.AWS_REGION }}"
          terraform apply -auto-approve -var="deploy_env=$DEPLOY_ENV" -var="image_digest=$IMAGE_DIGEST" -var="super_secret_token_arn=$SUPER_SECRET_TOKEN_ARN" -var="ecr_repo_url=$ECR_REPO_URL"
          echo "lambda_url=$(terraform output -raw lambda_api_url)" >> $GITHUB_OUTPUT
          cd ../..

          # Deploy EC2 Stack
          cd infra/ec2
          terraform init -input=false -backend-config="bucket=${{ env.TF_STATE_BUCKET }}" -backend-config="key=infra/ec2/$DEPLOY_ENV.tfstate" -backend-config="region=${{ env.AWS_REGION }}"
          terraform apply -auto-approve -var="deploy_env=$DEPLOY_ENV" -var="image_digest=$IMAGE_DIGEST" -var="super_secret_token_arn=$SUPER_SECRET_TOKEN_ARN" -var="ecr_repo_url=$ECR_REPO_URL"
          echo "alb_dns=$(terraform output -raw alb_dns)" >> $GITHUB_OUTPUT
          cd ../..

      - name: Trigger Dual-Target CodeDeploy
        id: codedeploy-trigger
        env:
          DEPLOY_ENV: dev
          IMAGE_DIGEST: ${{ github.event.inputs.image_digest }}
          SUPER_SECRET_TOKEN_ARN: arn:aws:secretsmanager:${{ env.AWS_REGION }}:${{ env.AWS_ACCOUNT_ID }}:secret:podinfo/dev/super-secret-token
        run: |
          set -euo pipefail
          
          # --- Lambda Deployment ---
          # Generate appspec dynamically
          cat > infra/lambda/appspec.yaml <<EOF
          version: 0.0
          Resources:
            - TargetService:
                Type: AWS::Lambda::Function
                Properties:
                  Name: "podinfo-$DEPLOY_ENV"
                  Alias: "live"
                  CurrentVersion: "\${currentVersion}"
                  TargetVersion: "\${targetVersion}"
          EOF
          LAMBDA_DEPLOY_ID=$(aws deploy create-deployment --application-name "podinfo-lambda-$DEPLOY_ENV" --deployment-group-name "lambda-group-$DEPLOY_ENV" --description "Deploy $IMAGE_DIGEST" --revision '{"revisionType":"AppSpecContent","appSpecContent":{"content":"'"$(cat infra/lambda/appspec.yaml)"'"}}' --query deploymentId --output text)
          echo "LAMBDA_CODEDEPLOY_ID=$LAMBDA_DEPLOY_ID" >> $GITHUB_ENV
          echo "Lambda deployment started: $LAMBDA_DEPLOY_ID"

          # --- EC2 Deployment ---
          mkdir -p deployment/scripts
          cp -r scripts/*.sh scripts/appspec.yml deployment/scripts/
          # Inject image digest and secrets ARN
          echo "IMAGE_URI=${{ steps.login-ecr.outputs.registry }}/${{ env.IMAGE_NAME }}@${{ github.event.inputs.image_digest }}" > deployment/scripts/.env
          echo "SUPER_SECRET_TOKEN_ARN=$SUPER_SECRET_TOKEN_ARN" >> deployment/scripts/.env
          echo "AWS_REGION=${{ env.AWS_REGION }}" >> deployment/scripts/.env
          
          cd deployment && zip -r ../deployment.zip . && cd ..
          
          aws s3 cp deployment.zip s3://$TF_STATE_BUCKET/deployments/podinfo-$DEPLOY_ENV-${{ github.run_id }}.zip
          EC2_DEPLOY_ID=$(aws deploy create-deployment --application-name "podinfo-ec2-$DEPLOY_ENV" --deployment-group-name "ec2-group-$DEPLOY_ENV" --s3-location bucket=$TF_STATE_BUCKET,key=deployments/podinfo-$DEPLOY_ENV-${{ github.run_id }}.zip,bundleType=zip --description "Deploy $IMAGE_DIGEST" --query deploymentId --output text)
          echo "EC2_CODEDEPLOY_ID=$EC2_DEPLOY_ID" >> $GITHUB_ENV
          echo "EC2 deployment started: $EC2_DEPLOY_ID"

      - name: Wait for Deployments and Run Smoke Tests
        env:
          LAMBDA_URL: ${{ steps.terraform-apply.outputs.lambda_url }}
          ALB_DNS: ${{ steps.terraform-apply.outputs.alb_dns }}
        run: |
          echo "Waiting for Lambda deployment (${{ env.LAMBDA_CODEDEPLOY_ID }}) to succeed..."
          aws deploy wait deployment-successful --deployment-id "${{ env.LAMBDA_CODEDEPLOY_ID }}"
          
          echo "Waiting for EC2 deployment (${{ env.EC2_CODEDEPLOY_ID }}) to succeed..."
          aws deploy wait deployment-successful --deployment-id "${{ env.EC2_CODEDEPLOY_ID }}"
          
          echo "Deployments successful. Running smoke tests..."
          sleep 10 # Allow targets to stabilize
          curl -sfS "$LAMBDA_URL/healthz"
          curl -sfS "https://$ALB_DNS/healthz"
          
          echo "### Dev Deploy Summary" >> $GITHUB_STEP_SUMMARY
          echo "- Image: ${{ env.IMAGE_NAME }}@${{ github.event.inputs.image_digest }}" >> $GITHUB_STEP_SUMMARY
          echo "- Lambda URL: $LAMBDA_URL" >> $GITHUB_STEP_SUMMARY
          echo "- ALB DNS: https://$ALB_DNS" >> $GITHUB_STEP_SUMMARY


  # ===================================================================
  #  JOB 2: Deploy to the 'prod' environment (with approval gate)
  # ===================================================================
  deploy-prod:
    name: Promote to Prod
    needs: deploy-dev # This ensures deploy-dev must succeed first
    runs-on: ubuntu-latest
    environment:
      name: prod # Links to the 'prod' GitHub Environment
      url: https://your-prod-url-here.com # Optional: display a link
    timeout-minutes: 30

    steps:
      # All steps are identical to 'deploy-dev' but parameterized for 'prod'
      # This is a perfect candidate for a reusable workflow (`workflow_call`)

      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Install dependencies (jq, yq, zip)
        run: |
          sudo apt-get update && sudo apt-get install -y jq zip
          sudo curl -L https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -o /usr/local/bin/yq && sudo chmod +x /usr/local/bin/yq

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_ACCOUNT_ID }}:role/github-actions-oidc-role
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Verify image signature (Cosign)
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_DIGEST: ${{ github.event.inputs.image_digest }} # Using the SAME digest
          COSIGN_EXPERIMENTAL: "1"
        run: |
          echo "Verifying image signature for $ECR_REGISTRY/$IMAGE_NAME@$IMAGE_DIGEST"
          curl -fsSL -o /usr/local/bin/cosign "https://github.com/sigstore/cosign/releases/download/v2.2.4/cosign-linux-amd64"
          chmod +x /usr/local/bin/cosign
          cosign verify "$ECR_REGISTRY/$IMAGE_NAME@$IMAGE_DIGEST" --certificate-oidc-issuer "https://token.actions.githubusercontent.com" --certificate-identity-regexp "https://github.com/.+"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.6

      - name: Deploy Infrastructure (Terraform)
        id: terraform-apply
        env:
          DEPLOY_ENV: prod
          ECR_REPO_URL: ${{ steps.login-ecr.outputs.registry }}/${{ env.IMAGE_NAME }}
          IMAGE_DIGEST: ${{ github.event.inputs.image_digest }}
          # IMPORTANT: Use a separate secret for prod!
          SUPER_SECRET_TOKEN_ARN: arn:aws:secretsmanager:${{ env.AWS_REGION }}:${{ env.AWS_ACCOUNT_ID }}:secret:podinfo/prod/super-secret-token
        run: |
          set -euo pipefail
          # Deploy Lambda Stack
          cd infra/lambda
          terraform init -input=false -backend-config="bucket=${{ env.TF_STATE_BUCKET }}" -backend-config="key=infra/lambda/$DEPLOY_ENV.tfstate" -backend-config="region=${{ env.AWS_REGION }}"
          terraform apply -auto-approve -var="deploy_env=$DEPLOY_ENV" -var="image_digest=$IMAGE_DIGEST" -var="super_secret_token_arn=$SUPER_SECRET_TOKEN_ARN" -var="ecr_repo_url=$ECR_REPO_URL"
          echo "lambda_url=$(terraform output -raw lambda_api_url)" >> $GITHUB_OUTPUT
          cd ../..

          # Deploy EC2 Stack
          cd infra/ec2
          terraform init -input=false -backend-config="bucket=${{ env.TF_STATE_BUCKET }}" -backend-config="key=infra/ec2/$DEPLOY_ENV.tfstate" -backend-config="region=${{ env.AWS_REGION }}"
          terraform apply -auto-approve -var="deploy_env=$DEPLOY_ENV" -var="image_digest=$IMAGE_DIGEST" -var="super_secret_token_arn=$SUPER_SECRET_TOKEN_ARN" -var="ecr_repo_url=$ECR_REPO_URL"
          echo "alb_dns=$(terraform output -raw alb_dns)" >> $GITHUB_OUTPUT
          cd ../..

      - name: Trigger Dual-Target CodeDeploy
        id: codedeploy-trigger
        env:
          DEPLOY_ENV: prod
          IMAGE_DIGEST: ${{ github.event.inputs.image_digest }}
          SUPER_SECRET_TOKEN_ARN: arn:aws:secretsmanager:${{ env.AWS_REGION }}:${{ env.AWS_ACCOUNT_ID }}:secret:podinfo/prod/super-secret-token
        run: |
          set -euo pipefail
          # --- Lambda Deployment ---
          cat > infra/lambda/appspec.yaml <<EOF
          version: 0.0
          Resources:
            - TargetService:
                Type: AWS::Lambda::Function
                Properties:
                  Name: "podinfo-$DEPLOY_ENV"
                  Alias: "live"
                  CurrentVersion: "\${currentVersion}"
                  TargetVersion: "\${targetVersion}"
          EOF
          LAMBDA_DEPLOY_ID=$(aws deploy create-deployment --application-name "podinfo-lambda-$DEPLOY_ENV" --deployment-group-name "lambda-group-$DEPLOY_ENV" --description "Deploy $IMAGE_DIGEST" --revision '{"revisionType":"AppSpecContent","appSpecContent":{"content":"'"$(cat infra/lambda/appspec.yaml)"'"}}' --query deploymentId --output text)
          echo "LAMBDA_CODEDEPLOY_ID=$LAMBDA_DEPLOY_ID" >> $GITHUB_ENV

          # --- EC2 Deployment ---
          mkdir -p deployment/scripts
          cp -r scripts/*.sh scripts/appspec.yml deployment/scripts/
          echo "IMAGE_URI=${{ steps.login-ecr.outputs.registry }}/${{ env.IMAGE_NAME }}@${{ github.event.inputs.image_digest }}" > deployment/scripts/.env
          echo "SUPER_SECRET_TOKEN_ARN=$SUPER_SECRET_TOKEN_ARN" >> deployment/scripts/.env
          echo "AWS_REGION=${{ env.AWS_REGION }}" >> deployment/scripts/.env
          cd deployment && zip -r ../deployment.zip . && cd ..
          aws s3 cp deployment.zip s3://$TF_STATE_BUCKET/deployments/podinfo-$DEPLOY_ENV-${{ github.run_id }}.zip
          EC2_DEPLOY_ID=$(aws deploy create-deployment --application-name "podinfo-ec2-$DEPLOY_ENV" --deployment-group-name "ec2-group-$DEPLOY_ENV" --s3-location bucket=$TF_STATE_BUCKET,key=deployments/podinfo-$DEPLOY_ENV-${{ github.run_id }}.zip,bundleType=zip --description "Deploy $IMAGE_DIGEST" --query deploymentId --output text)
          echo "EC2_CODEDEPLOY_ID=$EC2_DEPLOY_ID" >> $GITHUB_ENV

      - name: Wait for Deployments and Run Smoke Tests
        env:
          LAMBDA_URL: ${{ steps.terraform-apply.outputs.lambda_url }}
          ALB_DNS: ${{ steps.terraform-apply.outputs.alb_dns }}
        run: |
          echo "Waiting for Prod Lambda deployment (${{ env.LAMBDA_CODEDEPLOY_ID }}) to succeed..."
          aws deploy wait deployment-successful --deployment-id "${{ env.LAMBDA_CODEDEPLOY_ID }}"
          
          echo "Waiting for Prod EC2 deployment (${{ env.EC2_CODEDEPLOY_ID }}) to succeed..."
          aws deploy wait deployment-successful --deployment-id "${{ env.EC2_CODEDEPLOY_ID }}"
          
          echo "Prod deployments successful. Running smoke tests..."
          sleep 10 # Allow targets to stabilize
          curl -sfS "$LAMBDA_URL/healthz"
          curl -sfS "https://$ALB_DNS/healthz"

          echo "### Prod Deploy Summary" >> $GITHUB_STEP_SUMMARY
          echo "- Image: ${{ env.IMAGE_NAME }}@${{ github.event.inputs.image_digest }}" >> $GITHUB_STEP_SUMMARY
          echo "- Lambda URL: $LAMBDA_URL" >> $GITHUB_STEP_SUMMARY
          echo "- ALB DNS: https://$ALB_DNS" >> $GITHUB_STEP_SUMMARY